---
/**
 * Componente ResponsiveImage
 * 
 * Um componente avançado para exibir imagens responsivas com lazy loading e otimização para SEO.
 * Suporta imagens locais e remotas, formatos modernos (webp, avif) e placeholders.
 */

import { generatePlaceholder, isExternalImage } from '../utils/imageUtils';

interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  sizes?: string;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  class?: string;
  pictureClass?: string;
  aspectRatio?: string;
  objectFit?: 'contain' | 'cover' | 'fill' | 'none' | 'scale-down';
  background?: string;
  usePlaceholder?: boolean;
}

const {
  src,
  alt,
  width = 800,
  height = 600,
  sizes = '(max-width: 768px) 100vw, 50vw',
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  class: className = '',
  pictureClass = '',
  aspectRatio = 'auto',
  objectFit = 'cover',
  background = '#f8fafc',
  usePlaceholder = true
} = Astro.props;

// Verifica se a imagem é externa
const isExternal = isExternalImage(src);

// Gera um placeholder para quando a imagem estiver carregando
const placeholder = usePlaceholder ? generatePlaceholder(background, width, height) : '';

// Define os formatos de imagem modernos para o elemento <source>
const formats = ['webp', 'avif'];

// Calcula a proporção de aspecto para o estilo
const aspectRatioStyle = aspectRatio === 'auto' ? 'auto' : 
  aspectRatio.includes('/') ? aspectRatio : `${width} / ${height}`;

// Gera os tamanhos para srcset
const breakpoints = [320, 640, 960, 1280, 1920];
const filteredBreakpoints = breakpoints.filter(bp => bp <= width * 2);

// Função para gerar o srcset para um formato específico
function getSrcSet(format: string) {
  if (isExternal) return undefined;
  
  // Em um projeto real, você usaria a API de imagens do Astro ou um serviço como Cloudinary
  // Este é um exemplo simplificado
  return filteredBreakpoints
    .map(bp => {
      // Em um projeto real, você geraria URLs para imagens otimizadas
      // Por exemplo: `/images/optimized/${path.basename(src, path.extname(src))}-${bp}.${format}`
      return `${src} ${bp}w`;
    })
    .join(', ');
}
---

<div class={`relative overflow-hidden ${pictureClass}`} style={{
  aspectRatio: aspectRatioStyle,
  backgroundColor: background
}}>
  {usePlaceholder && (
    <div class="absolute inset-0 bg-no-repeat bg-center bg-cover" style={{
      backgroundImage: `url(${placeholder})`,
      filter: 'blur(10px)',
      transform: 'scale(1.1)',
      zIndex: 0
    }}></div>
  )}
  
  <picture class="w-full h-full">
    {!isExternal && formats.map(format => (
      <source 
        type={`image/${format}`} 
        srcset={getSrcSet(format)} 
        sizes={sizes} 
      />
    ))}
    
    <img
      src={src}
      alt={alt}
      width={width}
      height={height}
      loading={loading}
      decoding={decoding}
      fetchpriority={fetchpriority}
      class={`w-full h-full relative z-10 ${objectFit} ${className}`}
      style={{
        objectFit
      }}
    />
  </picture>
</div>

<style>
  img {
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
  }
  
  img.loading {
    opacity: 0;
  }
</style>

<script>
  // Script para detectar quando a imagem termina de carregar
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('img');
    
    images.forEach(img => {
      if (img.complete) {
        img.classList.remove('loading');
      } else {
        img.classList.add('loading');
        img.addEventListener('load', () => {
          img.classList.remove('loading');
        });
      }
    });
  });
</script>